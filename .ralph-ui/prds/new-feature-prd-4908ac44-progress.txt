# Ralph Wiggum Loop Progress
# This file tracks learnings across agent iterations.
# Each agent reads this file to catch up on context.
# Initialized: 2026-01-24T11:11:36.090461+00:00

[2026-01-24T11:11:49.093664+00:00] [Iter 1] [START] Starting iteration 1

[2026-01-24T12:14:00.000000+00:00] [Iter 1] [US-1.1] Story Completed: Access Essential Terminal Keys

<learning type="architecture">
Terminal input system uses writeToTerminal(terminalId, data) from src/lib/terminal-api.ts.
The function looks up the PTY instance and calls pty.write(data), which sends a JSON message
over WebSocket with type: 'input' and the data field. xterm.js handles the actual keyboard
events in TerminalInstance.tsx and connects via terminal.onData() callback.
</learning>

<learning type="pattern">
Mobile-specific UI patterns in this codebase:
- Use useIsMobile() hook to detect mobile
- Hide desktop-only features with conditional rendering (e.g., split controls)
- Use 'safe-bottom' CSS class for iOS safe area insets
- Test mobile components at 320px width minimum
- Use Tailwind responsive prefixes for scaling (md:, lg:)
</learning>

<learning type="pattern">
Escape sequences for terminal keys:
- Tab: '\t' (0x09)
- Enter: '\r' (0x0D)
- Backspace: '\x7f' (DEL character)
- ^C (interrupt): '\x03'
- Arrow keys: '\x1b[A' (up), '\x1b[B' (down), '\x1b[D' (left), '\x1b[C' (right)
- Home: '\x1b[H', End: '\x1b[F'
</learning>

<learning type="pattern">
Haptic feedback in React: Use navigator.vibrate(duration) for light feedback (10ms).
This is supported on most mobile devices. Always check availability with if (navigator.vibrate).
</learning>

<learning type="gotcha">
The TerminalPanel component renders terminals in a flex layout with recursive PaneRenderer.
When adding the key bar, wrap terminal content in a flex column container to allow flex-1
sizing to work correctly. Don't add the key bar directly at panel level.
</learning>
[2026-01-24T11:14:48.671465+00:00] [Iter 1] [END] Iteration 1 completed successfully
[2026-01-24T11:14:48.674575+00:00] [Iter 2] [START] Starting iteration 2

[2026-01-24T12:15:00.000000+00:00] [Iter 2] [US-1.2] Story Completed: Use Modifier Keys (Ctrl/Alt)

<learning type="pattern">
Modifier key implementation for terminal key bar:
- Track modifier state with useRef (lastClickRef) and useState (modifierState)
- Use 300ms window for double-tap detection (single tap = sticky, double tap = lock)
- Ctrl combinations: For single chars, use charCode - 96 to get Ctrl value (e.g., 'a' -> 0x01)
- Alt combinations: Send ESC prefix (0x1b) followed by the key
- Auto-clear sticky mode either after non-modifier key press or after 5-second timeout
- Visual feedback: bg-accent + text-accent-foreground for active, add border-2 + animate-pulse for locked
</learning>

<learning type="pattern">
Terminal modifier key handling in escape sequences:
- Ctrl+C is already defined as '\x03' (special interrupt sequence)
- For general Ctrl+letter combinations: charCode - 96 works for lowercase a-z
- Alt is represented by ESC prefix (\x1b) sent before the actual key
- The terminal emulator (xterm.js) interprets these sequences correctly
</learning>

<learning type="gotcha">
When implementing modifier keys, be careful about:
- Always clear the double-tap timeout when transitioning states (to avoid stale timeouts)
- Clean up timeouts on component unmount to prevent memory leaks
- Use separate state tracking for Ctrl vs Alt to allow independent modifier states
- Test that modifier state properly clears after non-modifier key press (sticky mode)
- Verify that lock mode persists across multiple key presses
</learning>
[2026-01-24T11:17:09.158966+00:00] [Iter 2] [END] Iteration 2 completed successfully
[2026-01-24T11:17:09.161442+00:00] [Iter 3] [START] Starting iteration 3

[2026-01-24T12:18:00.000000+00:00] [Iter 3] [US-1.3] Story Completed: Interrupt Running Processes

<learning type="pattern">
Interrupt button design for terminal key bar:
- The ^C button should always send pure interrupt signal (\x03), independent of modifier state
- Always separate modifier handling for interrupt key - check for button label before applying modifiers
- Use destructive styling (bg-destructive/10 text-destructive) to make interrupt button visually prominent
- Interrupt button state should not be affected by active modifiers (Ctrl/Alt)
</learning>

<learning type="gotcha">
When implementing special keys like interrupt (^C):
- Don't apply active modifiers (Ctrl/Alt prefix) to interrupt signals
- Always send clean interrupt value regardless of modifier state - this ensures reliability
- Structurally, check for special keys BEFORE modifier application logic, not inside
- This pattern makes the intent clear and prevents subtle bugs with modifier combinations
</learning>
[2026-01-24T12:18:30.000000+00:00] [Iter 3] [END] Iteration 3 completed successfully
[2026-01-24T11:19:10.528448+00:00] [Iter 3] [END] Iteration 3 completed successfully
[2026-01-24T11:19:10.532654+00:00] [Iter 4] [START] Starting iteration 4

[2026-01-24T12:20:00.000000+00:00] [Iter 4] [US-1.4] Story Completed: Auto-Hide Key Bar with Physical Keyboard

<learning type="pattern">
Physical keyboard detection for auto-hide functionality:
- Use KeyboardEvent.code property to detect physical keyboards (it's populated for hardware keys)
- Check event.code !== '' to ensure it's a real keyboard event, not virtual
- Exclude input/textarea keydown events as they trigger virtual keyboards on mobile
- Implement 2-second timeout that resets on each keyboard activity for seamless experience
- Use opacity-0 + pointer-events-none + max-h-0 for smooth fade animation with CSS transitions
</learning>

<learning type="pattern">
State management for visibility toggle in React:
- Use useState(true) for initial visibility to show key bar on first mount
- Track visibility separately from other states (modifier state, etc.)
- Use useEffect with dependency on isMobile and activeTerminalId to enable/disable listeners
- Clean up all event listeners and timeouts in useEffect return callback to prevent memory leaks
</learning>

<learning type="gotcha">
When implementing keyboard detection:
- The event listener must check both event.code AND !isFromInput to avoid false positives
- Always clear existing timeout before setting a new one to prevent race conditions
- Event delegation via window.addEventListener('keydown') works globally for all keyboard input
- Remember to handle visibilitychange event (tab switch) and explicitly show key bar to ensure UX
</learning>
[2026-01-24T12:20:30.000000+00:00] [Iter 4] [END] Iteration 4 completed successfully
[2026-01-24T11:20:59.056147+00:00] [Iter 4] [END] Iteration 4 completed successfully
[2026-01-24T11:20:59.060269+00:00] [Iter 5] [START] Starting iteration 5

[2026-01-24T12:25:00.000000+00:00] [Iter 5] [US-2.1] Story Completed: Rearrange Keys

<learning type="pattern">
Key bar layout customization architecture:
- Create separate Zustand store (keyBarLayoutStore) for layout persistence
- Store icon names as strings in the store (not React components) for serialization
- Map icon names to components in the component using a const ICON_MAP
- Use useMemo in TerminalKeyBar to convert stored layout to component layout on mount
- This separation ensures store data is serializable and components remain flexible
</learning>

<learning type="pattern">
HTML5 drag-and-drop implementation for key rearrangement:
- Use native HTML5 drag events: onDragStart, onDragOver, onDrop
- Track draggedIndex in state during the drag operation
- In onDragOver, prevent default and set dropEffect = 'move'
- In onDrop, splice the dragged item from source index and insert at target index
- Clear draggedIndex after drop completes
- This approach works without external libraries
</learning>

<learning type="pattern">
Integrating customizer into existing settings page:
- Add new component to appropriate settings tab (UI Preferences for key bar)
- Import the customizer component at top of SettingsPage
- Add it to the TabsContent section alongside other settings
- This keeps settings organized while maintaining modularity
</learning>

<learning type="gotcha">
When removing unused code from TerminalKeyBar:
- The DEFAULT_KEYS array is now defined in the store, not the component
- Remove it from the component to pass linting (no-unused-vars rule)
- The store exports DEFAULT_LAYOUT which can be referenced for reset functionality
</learning>

[2026-01-24T12:25:30.000000+00:00] [Iter 5] [END] Iteration 5 completed successfully
[2026-01-24T11:24:20.856651+00:00] [Iter 5] [END] Iteration 5 completed successfully
[2026-01-24T11:24:20.861714+00:00] [Iter 6] [START] Starting iteration 6

[2026-01-24T12:30:00.000000+00:00] [Iter 6] [US-2.2] Story Completed: Add and Remove Keys

<learning type="pattern">
Key palette implementation for terminal key bar:
- Define AVAILABLE_KEYS array in the Zustand store with 50+ keys categorized by type (navigation, editing, modifiers, control sequences, function keys, common characters)
- Use filter() to get available keys not already in the layout
- Implement search with toLowerCase() matching on both label and ariaLabel for better UX
- Separate palette visibility from main editor with a collapsible section (show/hide via state)
- Use grid layout (grid-cols-3) for compact palette display with max-h-64 overflow-y-auto for scrolling
</learning>

<learning type="pattern">
Add/remove constraints and validation for key bar:
- Define MIN_KEYS = 6 and MAX_KEYS_PER_ROW = 10 as constants
- Disable remove button (with visual feedback) when at minimum keys using opacity-50 + cursor-not-allowed
- Show helpful tooltip when action is disabled to explain the constraint
- Calculate rows by dividing layout into chunks of MAX_KEYS_PER_ROW for visual row preview
- Validate constraints in handleSave() before persisting to store, show alert on failure
- Show row count and key count in the preview section to help users understand layout
</learning>

<learning type="pattern">
Visual feedback for add/remove operations:
- Show live preview that updates immediately as keys are added/removed (not just on save)
- Display row-based layout preview to show how keys will wrap at max per-row constraint
- Show count of available keys and current key count for transparency
- Display "All available keys are in use" message when palette is full
- Use "unsaved changes" warning to ensure user explicitly saves before changes persist
- Clear search query after adding key to keep UI clean
</learning>

<learning type="gotcha">
When managing complex component state with multiple related fields:
- Must track both layout state and hasChanges state separately
- searchQuery and showPalette are UI-only state that don't need to be persisted
- Use useMemo or inline calculations for derived values like availableKeysToAdd and filteredAvailableKeys
- Calculate canRemoveMore and isFull at render time to ensure they stay in sync with layout
- Test that all state transitions are correct (adding, removing, searching, palette toggle)
</learning>

[2026-01-24T12:30:30.000000+00:00] [Iter 6] [END] Iteration 6 completed successfully
[2026-01-24T11:27:05.443680+00:00] [Iter 6] [END] Iteration 6 completed successfully
[2026-01-24T11:27:05.446978+00:00] [Iter 7] [START] Starting iteration 7

[2026-01-24T12:35:00.000000+00:00] [Iter 7] [US-2.3] Story Completed: Use and Save Presets

<learning type="pattern">
Preset system implementation for terminal key bar:
- Create Preset interface with id, name, layout, and isBuiltin flag
- Store presets array in Zustand with built-in presets initialized by default
- Track activePresetId to know which preset is currently selected
- Implement store methods: savePreset (generates ID from timestamp), switchPreset, deletePreset, getActivePreset
- Built-in presets cannot be deleted (checked via isBuiltin flag)
- Custom presets get unique IDs like 'preset-custom-{timestamp}'
- When switching presets, clear customLayout to ensure preset layout is used
- All preset operations persist to localStorage via Zustand persist middleware
</learning>

<learning type="pattern">
Preset UI implementation in key bar customizer:
- Display presets in a vertical list with one button per preset
- Highlight active preset with accent color and border-2
- Show delete button only for custom presets (isBuiltin === false)
- "Save as preset" button disabled when no changes (hasChanges === false)
- Use controlled input dialog for preset name with Enter key support
- Show preset list above the current layout preview for easy discoverability
- Grid layout breaks down on mobile (single preset per row) and expands to 2-4 cols on md+
</learning>

<learning type="pattern">
Built-in presets design:
- Default: Full keyboard layout with all standard keys
- Git: Optimized for git workflows (arrows, slash, hyphen, Ctrl, Alt, ^C)
- Vim: Optimized for vim/nano editors (arrows, colon, slash, Escape key)
- Node: Optimized for JavaScript development (parens, braces, semicolon, colon)
- Each preset has 11-12 keys (respects MIN_KEYS = 6 and MAX_KEYS_PER_ROW = 10)
</learning>

<learning type="gotcha">
When implementing preset switching:
- Must clear customLayout when switching presets to avoid confusion
- activePresetId should be set to 'preset-default' when deleting the active custom preset
- Store methods should validate that presets exist before returning them (defensive coding)
- Be careful with preset IDs - use consistent naming scheme for builtin (preset-{name}) vs custom (preset-custom-{timestamp})
</learning>
[2026-01-24T12:35:30.000000+00:00] [Iter 7] [END] Iteration 7 completed successfully
[2026-01-24T11:29:09.507687+00:00] [Iter 7] [END] Iteration 7 completed successfully
[2026-01-24T11:29:09.511374+00:00] [Iter 8] [START] Starting iteration 8

[2026-01-24T12:40:00.000000+00:00] [Iter 8] [US-3.1] Story Completed: Save Frequently Used Commands

<learning type="pattern">
Custom commands store implementation for terminal:
- Create dedicated Zustand store with localStorage persistence (useCustomCommandsStore)
- Store interface: CustomCommand with id, label, command, createdAt timestamp
- Store actions: addCommand, deleteCommand, getCommands
- Command IDs use format 'cmd-{timestamp}' for unique identification
- All store data is serializable (no React components)
</learning>

<learning type="pattern">
Custom commands side sheet UI architecture:
- CustomCommandsSheet component wraps mobile-friendly sheet UI for command management
- Includes form for adding commands with label and command text inputs
- Shows all saved commands in a scrollable list
- Each command has a clickable label/command area to execute and delete button
- Uses writeToTerminal(activeTerminalId, command) to execute saved commands
- Empty state message when no commands exist
</learning>

<learning type="pattern">
Integration with TerminalKeyBar:
- Add CustomCommandsSheet import and state (isCommandsSheetOpen)
- Add custom commands button (BookOpen icon) at the end of the key bar
- Button opens sheet via onClick handler
- Sheet is rendered as sibling to key bar div to avoid z-index issues
- Fragment wrapper needed when returning both key bar and sheet
</learning>

<learning type="gotcha">
When adding multiple components to TerminalKeyBar:
- Must wrap in Fragment (<>) when returning multiple JSX elements
- Import additional icons needed for new buttons (BookOpen for custom commands)
- Clean up unused imports to pass linting (cn was imported but not used initially)
- All button styling should follow existing patterns (min-h-[32px] min-w-[40px])
</learning>

[2026-01-24T12:40:30.000000+00:00] [Iter 8] [END] Iteration 8 completed successfully
[2026-01-24T11:31:38.143409+00:00] [Iter 8] [END] Iteration 8 completed successfully
[2026-01-24T11:31:38.147972+00:00] [Iter 9] [START] Starting iteration 9

[2026-01-24T12:45:00.000000+00:00] [Iter 9] [US-3.2] Story Completed: Choose Insert vs Execute Action

<learning type="pattern">
Custom command action type implementation for terminal:
- Add action: 'insert' | 'execute' field to CustomCommand interface
- Store tracks action type along with label and command text
- When creating commands, default action is 'execute' for convenience
- Execute action sends newline (\r) after the command to run it
- Insert action only pastes the command text without sending newline
- Visual badge shows action type: "‚Üµ Execute" (primary/blue) or "‚Üê Insert" (secondary)
- Uses conditional className based on action type to differentiate styling
</learning>

<learning type="pattern">
Form pattern for enum selection in React:
- Use controlled input with select element
- Pass action to handleAddCommand function
- Reset action to default ('execute') on form cancel to avoid state leakage
- Use TypeScript type casting: e.target.value as 'insert' | 'execute'
- Show user-friendly labels in options ("Insert (no newline)" vs "Execute (with newline)")
</learning>

<learning type="gotcha">
When implementing command execution with multiple behavior options:
- Must track which action type was selected with the command
- Store action type persistently so it applies when command is reused
- Default to 'execute' since most users expect commands to run automatically
- Visual indicator must be clear and discoverable (badge at bottom of command card)
- Test that both actions work correctly: insert (no newline) and execute (with newline)
</learning>
[2026-01-24T12:45:30.000000+00:00] [Iter 9] [END] Iteration 9 completed successfully
[2026-01-24T11:33:41.104011+00:00] [Iter 9] [END] Iteration 9 completed successfully
[2026-01-24T11:33:41.106968+00:00] [Iter 10] [START] Starting iteration 10

[2026-01-24T12:50:00.000000+00:00] [Iter 10] [US-3.3] Story Completed: Organize Commands with Categories

<learning type="pattern">
Command category system implementation for terminal:
- Add category: string field to CustomCommand interface
- Store methods: getCommandsByCategory(category) and getAllCategories() return filtered/unique categories
- Sheet state: expandedCategories is Set<string> to track which categories are expanded
- Grouping: Use useMemo to create groupedCommands Record<string, CustomCommand[]> with Object.entries().sort()
- UI: Category headers with ChevronDown/ChevronRight icons toggle visibility, commands nested in container
- Filtering: selectedFilter state with filter buttons showing counts per category
- Form: Category select dropdown with special option for new categories (value="") then input field to enter name
</learning>

<learning type="gotcha">
When implementing category features:
- Must track expandedCategories as a Set, not array, for O(1) lookups when toggling visibility
- Category selection form needs special handling for new categories: select value="" shows input field
- Need to reset category back to 'Uncategorized' when closing form to avoid state leakage
- getAllCategories() must use Set to deduplicate then sort alphabetically for consistent UI
- groupedCommands needs proper Object.entries().sort() to ensure consistent ordering across renders
</learning>
[2026-01-24T11:35:41.699632+00:00] [Iter 10] [END] Iteration 10 completed successfully
[2026-01-24T11:35:41.702181+00:00] [Iter 11] [START] Starting iteration 11

[2026-01-24T12:55:00.000000+00:00] [Iter 11] [US-3.4] Story Completed: Search Commands

<learning type="pattern">
Search functionality implementation for custom commands:
- Add searchQuery state to track user input
- Create filteredCommands useMemo that filters based on searchQuery using toLowerCase() matching on both label and command fields
- Create displayedGroups useMemo that groups filtered commands by category and applies category filter
- Show search input conditionally: only when commands.length > 10
- Add X (clear) button using lucide-react's X icon that appears when searchQuery is non-empty
- Update category filter counts to use filteredCommands instead of commands for accurate filtering display
- Remove old unused groupedCommands memoization to pass linting
</learning>

<learning type="pattern">
Search UI placement and interaction:
- Search input appears after the "Add Command" button and before the "Add Command Form"
- Use relative positioning for the clear button (X icon) positioned at right side of input
- Search field has placeholder "Search commands..." to guide users
- Results update immediately as user types (real-time filtering)
- Clear button has aria-label for accessibility
</learning>

<learning type="gotcha">
When implementing filtered search with category grouping:
- Must ensure both useMemo dependencies are correct (filteredCommands in displayedGroups, searchQuery in filteredCommands)
- Category filter counts must use filteredCommands not commands to show correct filtered counts
- The old groupedCommands memoization should be removed to avoid unused variable errors
- Search query should be reset when user clears (happens automatically via setSearchQuery)
</learning>
[2026-01-24T11:37:11.330265+00:00] [Iter 11] [END] Iteration 11 completed successfully
[2026-01-24T11:37:11.332687+00:00] [Iter 12] [START] Starting iteration 12

[2026-01-24T12:58:00.000000+00:00] [Iter 12] [US-3.5] Story Completed: Manage Commands (Edit/Delete/Reorder)

<learning type="pattern">
Command edit/delete/reorder implementation for custom commands:
- Add sortOrder field to CustomCommand interface to track drag-and-drop order
- Store actions: editCommand updates existing command fields, reorderCommands replaces entire array
- Edit flow: populate form fields from existing command, set editingId, then call editCommand on save
- Delete flow: use deleteConfirmId state for confirmation dialog to prevent accidental deletion
- Reorder flow: track draggedIndex on drag start, find target index on drop, splice and reorder array
- Form UX: show "Edit Command" vs "Add New Command" title based on editingId, reset form on cancel
</learning>

<learning type="pattern">
HTML5 drag-and-drop for list reordering in React:
- Use draggable attribute on each item to enable native drag events
- Track draggedIndex in state during drag operation
- onDragStart captures which index is being dragged
- onDragOver(e) prevents default and sets dropEffect='move' to show move cursor
- onDrop(targetIndex) reorders array: splice dragged item, insert at target, update state
- Visual feedback: apply opacity-50 to dragged item, change background color for drop target
- Important: Clear draggedIndex after drop to reset visual state
</learning>

<learning type="gotcha">
When implementing edit functionality alongside add:
- Must track editingId state separately to know if in edit mode
- Form fields need proper initialization from existing command data
- Must reset editingId to null after save to avoid stale state
- handleCancelForm must reset all fields AND editingId to prevent form leaking state
- Reset form fields on successful add/edit to prepare for next operation
</learning>

<learning type="gotcha">
When adding multiple buttons (edit/delete) to command cards:
- Wrap buttons in flex container with gap-1 to keep them close together
- Use separate w-6 h-6 styling for consistency with previous delete-only design
- For delete, use deleteConfirmId state instead of immediate deletion
- Confirmation dialog prevents accidental deletions from mobile fat-finger errors
- Delete confirmation is shown inline on the command card, not as separate modal
</learning>
[2026-01-24T11:39:42.000000+00:00] [Iter 12] [END] Iteration 12 completed successfully
[2026-01-24T11:39:02.179644+00:00] [Iter 12] [END] Iteration 12 completed successfully
[2026-01-24T11:39:02.183810+00:00] [Iter 13] [START] Starting iteration 13

[2026-01-24T12:60:00.000000+00:00] [Iter 13] [US-4.1] Story Completed: Sync Commands Within a Project

<learning type="pattern">
Project-scoped command storage implementation:
- Add scope field to CustomCommand interface: 'local' | 'project' | 'global'
- Create dedicated backend module (server/src/commands/terminal.rs) for terminal commands
- Implement two async functions: save_project_commands and load_project_commands
- Store project commands in {projectPath}/.ralph-ui/terminal/commands.json for git tracking
- Use atomic writes (write to temp, rename) for safe file operations
- Zustand store handles merging local + project commands on load
</learning>

<learning type="pattern">
Backend command routing pattern:
- Add new command handlers to server/src/server/proxy.rs route_command match statement
- Use route_async! macro for async commands that return values
- Register new modules in server/src/commands/mod.rs (both pub mod and pub use)
- Frontend invoke() calls automatically route to backend handlers
- All backend functions return Result<T, String> or Result<Value, String>
</learning>

<learning type="pattern">
Frontend scope selection UI:
- Add scope state to form component alongside existing action, category, label, command
- Create select dropdown with three options: Local, Project (disabled if no projectPath), Global (disabled, coming soon)
- Show visual scope badges on command cards with different colors (üì± Local, üîÑ Project, üåê Global)
- Make save/cancel buttons disabled during async operations to prevent double-submit
</learning>

<learning type="gotcha">
When implementing scope feature:
- Must pass scope parameter through all store methods: addCommand, editCommand, deleteCommand, reorderCommands
- All store methods become async because they may need to sync with backend
- Need to track projectPath in store and only attempt save if projectPath is set
- Default scope should be 'local' unless editing existing command with different scope
- Each scope-specific operation filters commands before syncing to backend
</learning>

[2026-01-24T12:62:00.000000+00:00] [Iter 13] [END] Iteration 13 completed successfully
[2026-01-24T11:43:03.213023+00:00] [Iter 13] [END] Iteration 13 completed successfully
[2026-01-24T11:43:03.215578+00:00] [Iter 14] [START] Starting iteration 14

[2026-01-24T13:00:00.000000+00:00] [Iter 14] [US-4.2] Story Completed: Sync Commands Across All Projects

<learning type="pattern">
Global command storage implementation follows the same pattern as project-scoped commands:
- Add save_global_commands(commands) and load_global_commands() functions to terminal.rs
- Use dirs::home_dir() to get the home directory path
- Store global commands in ~/.ralph-ui/terminal/commands.json using atomic writes
- Register new backend routes in proxy.rs using route_async! macro
- Update Zustand store methods to handle global scope synchronization
- Call load_global_commands() when loading project commands to merge all scopes
</learning>

<learning type="pattern">
Frontend store pattern for multi-scope persistence:
- Each store method (addCommand, deleteCommand, editCommand, reorderCommands) needs to check command scope
- If scope is 'project', sync via invoke('save_project_commands', ...)
- If scope is 'global', sync via invoke('save_global_commands', ...)
- Local scope commands never sync - they stay in localStorage only
- loadProjectCommands now loads both project AND global commands, merging them with local commands
</learning>

<learning type="gotcha">
When enabling a disabled option in a select element:
- The option element itself should not have the disabled attribute
- Instead, remove the disabled attribute from the select element for that option
- Example: <option value="global">Global (all projects)</option> (no disabled attribute)
- This allows users to select it while keeping project scope disabled when projectPath is missing
</learning>
[2026-01-24T11:47:35.721489+00:00] [Iter 14] [END] Iteration 14 completed successfully
[2026-01-24T11:47:35.724113+00:00] [Iter 15] [START] Starting iteration 15

[2026-01-24T13:05:00.000000+00:00] [Iter 15] [US-4.3] Story Completed: Keep Private Commands Local

<learning type="pattern">
Local scope command implementation (US-4.3) leverages existing scope system from US-4.1/4.2:
- LocalScope commands are created with scope: 'local' (default in CustomCommandsSheet line 23)
- In customCommandsStore.ts: addCommand, deleteCommand, editCommand, reorderCommands all check for scope
- For 'local' scope: NO backend calls are made - commands stay in localStorage via Zustand persist
- For 'project' and 'global': backend sync functions (invoke('save_project_commands') / invoke('save_global_commands')) are called
- This ensures local commands never appear in project files (.ralph-ui/terminal/commands.json)
</learning>

<learning type="pattern">
Scope badge visual indicators display correctly in command cards:
- Line 437 in CustomCommandsSheet.tsx: 'üì± Local' badge (gray: bg-muted/20 text-muted-foreground)
- Line 431: 'üîÑ Project' badge (blue: bg-blue/20 text-blue)
- Line 433: 'üåê Global' badge (purple: bg-purple/20 text-purple)
- Each scope has distinct color to make scope clear at a glance
- Badges appear inline on every command card below the action badge
</learning>

<learning type="pattern">
Default scope in custom commands form:
- Initial state in CustomCommandsSheet line 23: setScope('local')
- Form reset in handleCancelForm (line 103): setScope('local')
- Form reset after successful save (line 77): setScope('local')
- Scope dropdown shows "Local (this device only)" as first option (line 283)
- This ensures all new commands default to local scope for privacy
</learning>

<learning type="gotcha">
When implementing scope-based persistence:
- Must check scope in EVERY store method (addCommand, deleteCommand, editCommand, reorderCommands)
- Local scope must have NO backend calls - not even empty ones
- Backend calls should only happen for 'project' and 'global' scopes
- The Zustand persist middleware automatically saves all scopes to localStorage
- Only scope 'local' uses localStorage; 'project' and 'global' also use localStorage AND backend files
</learning>

[2026-01-24T13:05:30.000000+00:00] [Iter 15] [END] Iteration 15 completed successfully
[2026-01-24T11:49:08.646429+00:00] [Iter 15] [END] Iteration 15 completed successfully
[2026-01-24T11:49:08.650158+00:00] [Iter 16] [START] Starting iteration 16

[2026-01-24T13:10:00.000000+00:00] [Iter 16] [US-4.4] Story Completed: Understand Command Priority

<learning type="pattern">
Command priority resolution system implementation:
- Create utility functions in src/lib/command-priority.ts: findCommandOverrides(), isCommandOverriding(), getEffectiveCommand()
- findCommandOverrides() groups commands by label and returns map with effective command and overrides array
- Priority order: scope === 'project' (0) > scope === 'global' (1) > scope === 'local' (2)
- Override detection: check if a command is overriding another with same label using isCommandOverriding()
</learning>

<learning type="pattern">
Command override UI implementation in custom commands sheet:
- Add viewingOverrideFor state to track which override the user is viewing
- Show "Overrides" badge button only for project-scoped commands that have a global override
- Badge uses amber/warning color to indicate override state
- Click badge to view original global command in expandable section below the command
- Override view shows both label and command text of the overridden global command
</learning>

<learning type="pattern">
Priority documentation in UI:
- Add priority info section at top of CustomCommandsSheet showing priority order
- Use blue background (info color) for priority documentation
- Show priority as numbered list with scope icons (üîÑ Project, üåê Global, üì± Local)
- Explain that if commands have same label, highest priority version is used
</learning>

<learning type="gotcha">
When grouping commands by label for override detection:
- Must handle case where multiple global and local commands exist with same label
- Override relationship only matters for project > global, not project > local or global > local
- Store only the global override, not local ones, to avoid clutter in UI
- Use command IDs to track which specific command is being edited/viewed to avoid reference issues
</learning>

[2026-01-24T13:10:30.000000+00:00] [Iter 16] [END] Iteration 16 completed successfully
[2026-01-24T11:51:31.411469+00:00] [Iter 16] [END] Iteration 16 completed successfully
[2026-01-24T11:51:31.414063+00:00] [Iter 17] [START] Starting iteration 17

[2026-01-24T13:15:00.000000+00:00] [Iter 17] [US-5.1] Story Completed: Navigate Command History with Gestures

<learning type="pattern">
Gesture detection implementation for mobile terminal swipe navigation:
- Create useGestureDetection hook with touch event listeners for single-finger swipes
- Track touchStart, touchMove, touchEnd events to calculate swipe distance and direction
- Distinguish between vertical (up/down) and horizontal (left/right) swipes using dx/dy comparison
- Use threshold parameter (default 30px) to filter out accidental touches
- Return gestureState with isDetecting, direction, and distance for real-time feedback
- Support callbacks: onSwipeUp, onSwipeDown, onSwipeLeft, onSwipeRight, onGestureStart, onGestureEnd
</learning>

<learning type="pattern">
Command history navigation via gestures sends arrow key escape sequences:
- Swipe up: writeToTerminal(terminalId, '\x1b[A') - same as pressing up arrow (recall previous command)
- Swipe down: writeToTerminal(terminalId, '\x1b[B') - same as pressing down arrow (recall next command)
- These sequences work with any shell that supports readline (bash, zsh, sh, etc.)
- The terminal interprets them as if user pressed physical arrow keys
</learning>

<learning type="pattern">
Gesture settings store pattern using Zustand:
- Create settings store with feature toggles and threshold configuration
- Support enable/disable for each gesture feature independently
- Store thresholds as number values (pixel distance for swipes, scale factor for pinches)
- Provide both individual toggle methods and bulk resetToDefaults
- Use partialize to persist only settings, not all store state
</learning>

<learning type="pattern">
Visual gesture feedback on terminal:
- Show animated overlay with direction indicator (‚Üë Previous or ‚Üì Next)
- Use fadeOut CSS animation (0.3s) to smoothly hide feedback
- Position indicator absolutely over terminal content to avoid blocking interaction
- Apply opacity-based reveal (0.3) with colored background (blue for up, green for down)
- Clear gesture indicator after 200ms to provide instant visual confirmation
</learning>

<learning type="pattern">
Gesture settings UI component in settings page:
- Add GestureSettings component to UI Preferences tab (after KeyBarCustomizer)
- Provide feature card with toggle switch for enabling/disabling
- Show conditionally rendered threshold slider when feature is enabled
- Include placeholder section for future gesture features (cursor movement, page scrolling, pinch-zoom)
- Add reset button to restore default settings
</learning>

<learning type="gotcha">
When using useGestureDetection hook with TerminalInstance:
- Remember to remove unused gestureState variable if not using it for display
- Add elementRef to useEffect dependencies to avoid stale closures
- The hook should be enabled only when settings.enableHistoryNavigation && isActive to avoid processing gestures when terminal is not active
- TouchEvent listeners should be passive: true to avoid blocking scrolling on mobile devices
</learning>

[2026-01-24T13:15:30.000000+00:00] [Iter 17] [END] Iteration 17 completed successfully
[2026-01-24T11:54:29.768300+00:00] [Iter 17] [END] Iteration 17 completed successfully
[2026-01-24T11:54:29.770765+00:00] [Iter 18] [START] Starting iteration 18

[2026-01-24T13:20:00.000000+00:00] [Iter 18] [US-5.2] Story Completed: Move Cursor with Gestures

<learning type="pattern">
Cursor movement gesture implementation for mobile terminal:
- Use horizontal swipes (left/right) in useGestureDetection hook
- Track swipe distance from gestureState to determine velocity
- Slow swipe (normal threshold): send single character movement escape sequences
  - Left: '\x1b[D' (Left arrow key)
  - Right: '\x1b[C' (Right arrow key)
- Fast swipe (distance > 2x threshold): send word movement with Ctrl modifier
  - Left: '\x1b[1;5D' (Ctrl+Left - move by word)
  - Right: '\x1b[1;5C' (Ctrl+Right - move by word)
- This pattern allows a single gesture direction to have two behaviors based on velocity
</learning>

<learning type="pattern">
Multi-gesture support in useGestureDetection hook:
- Enable threshold must check ALL gesture types that will be used (use Math.min for multiple thresholds)
- Each gesture direction gets its own handler (onSwipeUp, onSwipeDown, onSwipeLeft, onSwipeRight)
- Settings store already had enableCursorMovement and cursorSwipeThreshold defined
- No changes needed to gesture detection hook itself - it already supports all 4 directions
- Just needed to add handlers and enable logic to TerminalInstance.tsx
</learning>

<learning type="pattern">
Gesture settings UI integration for new features:
- Add destructuring for new toggle/setter functions in component imports
- Replace placeholder "Coming Soon" section with actual feature controls
- Show settings conditionally: toggle switch + threshold slider when enabled
- Update slider description to explain the relationship between slow (character) and fast (word) movement
- Can reuse existing Label/Slider/Switch components for consistency
</learning>

<learning type="pattern">
Gesture indicator display for multiple directions:
- Use conditional rendering with direction-specific colors:
  - Up (history): blue (rgba(59, 130, 246, 0.2))
  - Down (history): green (rgba(34, 197, 94, 0.2))
  - Left (cursor): purple (rgba(168, 85, 247, 0.2))
  - Right (cursor): orange (rgba(249, 115, 22, 0.2))
- Update gestureIndicator type to union: 'up' | 'down' | 'left' | 'right' | null
- Use ternary chains for conditional styling and text display
</learning>

[2026-01-24T13:20:30.000000+00:00] [Iter 18] [END] Iteration 18 completed successfully
[2026-01-24T11:56:26.829846+00:00] [Iter 18] [END] Iteration 18 completed successfully
[2026-01-24T11:56:26.833467+00:00] [Iter 19] [START] Starting iteration 19

[2026-01-24T13:25:00.000000+00:00] [Iter 19] [US-5.3] Story Completed: Page Through Terminal Output

<learning type="pattern">
Two-finger gesture support in useGestureDetection hook:
- Track both single-finger (e.touches.length === 1) and two-finger (e.touches.length === 2) swipes
- In handleTouchStart/Move, check e.touches.length !== 1 && e.touches.length !== 2 to allow both
- In handleTouchEnd, detect two-finger by checking e.changedTouches.length === 2
- Use onTwoFingerSwipeUp/Down callbacks for two-finger vertical swipes
- Two-finger swipes use Page Up/Down escape sequences: '\x1b[5~' (Page Up) and '\x1b[6~' (Page Down)
- Importantly: only process one touch point (e.touches[0]) for movement detection, ignoring second finger position
- This allows two-finger swipe to work naturally while avoiding conflicts with pinch gestures
</learning>

<learning type="pattern">
Page scrolling gesture escape sequences:
- Page Up: '\x1b[5~' (same as physical Page Up key)
- Page Down: '\x1b[6~' (same as physical Page Down key)
- These work with terminal scrollback in most terminal emulators (xterm, tmux, less, etc.)
- Works smoothly in vim pagination modes and terminal pagers
</learning>

<learning type="architecture">
Gesture feature detection should be enabled in gesture store defaults when story completes:
- enablePageScroll: true (was false during development)
- enableCursorMovement: true (from previous US-5.2, was false)
- This allows features to work immediately after implementation
- Gesture settings are persisted via Zustand persist middleware, so defaults only apply on fresh install
</learning>

<learning type="pattern">
Touch event type handling in TypeScript:
- handleTouchEnd callback receives TouchEvent parameter for accessing e.changedTouches
- Must cast event listener to EventListener type when registering: handleTouchEnd as EventListener
- This is necessary because TouchEvent and EventListener have different type signatures in TypeScript
- Add callbacks to dependency array: onTwoFingerSwipeUp, onTwoFingerSwipeDown
</learning>

<learning type="gotcha">
Two-finger swipe detection reliability:
- Mobile browsers vary in touch handling - some may drop the second touch point
- Testing on real devices recommended since browser simulators may not accurately simulate multi-touch
- The implementation tolerates second finger disappearing mid-gesture (doesn't cancel)
- Distinguishing between pinch (changing distance between two fingers) and swipe (parallel movement) requires measuring distance between both fingers - current implementation only checks one finger position, which naturally avoids pinch conflicts
</learning>

[2026-01-24T13:25:30.000000+00:00] [Iter 19] [END] Iteration 19 completed successfully
[2026-01-24T11:58:27.388883+00:00] [Iter 19] [END] Iteration 19 completed successfully
[2026-01-24T11:58:27.391458+00:00] [Iter 20] [START] Starting iteration 20

[2026-01-24T13:30:00.000000+00:00] [Iter 20] [US-5.4] Story Completed: Extended Arrow Key Gestures

<learning type="pattern">
Extended arrow key gesture implementation in terminal key bar:
- Track touch start position in useRef to detect swipes on arrow keys
- In handleArrowTouchEnd, calculate dx/dy between start and end positions
- Compare distance against settings.extendedSwipeThreshold to distinguish swipe from tap
- Use absDx > absDy to determine if gesture is vertical (up/down) or horizontal (left/right)
- Send appropriate escape sequences based on key and swipe direction:
  - Swipe up on ‚Üë: '\x1b[5~' (Page Up)
  - Swipe down on ‚Üì: '\x1b[6~' (Page Down)
  - Swipe left on ‚Üê: '\x01' (Ctrl+A, Home)
  - Swipe right on ‚Üí: '\x05' (Ctrl+E, End)
- Gesture detection is controlled by settings.enableExtendedArrows feature toggle
</learning>

<learning type="pattern">
Visual hint implementation for extended arrow gestures:
- Render ChevronDown icon above arrow keys when feature is enabled
- Show hint on hover (desktop) or always on mobile via isMobile check
- Rotate icon based on arrow direction (180¬∞ for up, 0¬∞ for down, 90¬∞ for left, -90¬∞ for right)
- Apply animate-pulse class for subtle animation indicating interactivity
- Use absolute positioning (bottom-full, left-1/2 with -translate-x-1/2) to position above button
- Set pointer-events-none to prevent hint from interfering with touch/click interactions
</learning>

<learning type="pattern">
Touch event handling for arrow key gestures in React:
- Add onTouchStart and onTouchEnd handlers to buttons that support extended gestures
- Use e.touches[0] in onTouchStart to get initial position
- Use e.changedTouches[0] in onTouchEnd to get final position
- React TouchEvent typing: React.TouchEvent provides proper types for touch events
- Remember: touching requires passing keyLabel to handler function for context
</learning>

<learning type="gotcha">
React Hook dependencies with gesture settings:
- When using settings object in useCallback, must include specific properties as dependencies
- React Compiler will warn if inferred dependencies don't match specified ones
- Include both settings.enableExtendedArrows AND settings.extendedSwipeThreshold in dependency array
- This ensures handlers update when threshold changes, allowing dynamic gesture sensitivity adjustment
</learning>

[2026-01-24T13:30:30.000000+00:00] [Iter 20] [END] Iteration 20 completed successfully
[2026-01-24T12:00:34.266387+00:00] [Iter 20] [END] Iteration 20 completed successfully
[2026-01-24T12:00:34.269685+00:00] [Iter 21] [START] Starting iteration 21

[2026-01-24T13:35:00.000000+00:00] [Iter 21] [US-5.5] Story Completed: Adjust Terminal Font Size

<learning type="pattern">
Pinch gesture detection implementation in useGestureDetection hook:
- Track both touch points separately: touchStartRef, touchSecondStartRef for initial positions
- Calculate initial distance between two fingers using getDistance helper function
- In handleTouchMove, detect two-finger gesture by checking e.touches.length === 2
- Calculate scale as currentDistance / initialPinchDistance (ratio between current and initial)
- Scale > 1.0 means pinch out (zoom in), scale < 1.0 means pinch in (zoom out)
- Return scale in gestureState so handlers can determine direction and magnitude
</learning>

<learning type="pattern">
Font size management in gesture store:
- Store terminalFontSize, minFontSize, maxFontSize in settings interface
- Initialize defaults: fontSize=13px, min=8px, max=32px
- setTerminalFontSize method clamps value: Math.max(min, Math.min(value, max))
- Zustand persist middleware automatically saves to localStorage with name 'ralph-gesture-settings'
- Enable pinch feature with enablePinchZoom=true by default so feature works immediately
</learning>

<learning type="pattern">
TerminalInstance integration with pinch gestures:
- Create useCallback handlers (handlePinchIn, handlePinchOut) with proper dependencies
- Use scale parameter directly: newFontSize = Math.round(currentFontSize * scale)
- After setting font size in store, update xterm: terminalRef.current.options.fontSize = newSize
- Call fitAddonRef.current?.fit() after changing fontSize to recalculate terminal dimensions
- Add separate effect (useEffect) for font size updates to avoid reinitializing terminal
- Include settings.terminalFontSize in initialization effect dependency to load stored size on mount
</learning>

<learning type="pattern">
GestureSettings UI component for font size and other gesture controls:
- Import all toggle and setter functions from gesture store
- Create separate card sections for each gesture feature (Command History, Cursor Movement, Page Scroll, Extended Arrows, Pinch Zoom)
- Each section has toggle switch + conditionally rendered controls (show only when enabled)
- Font size slider: min=minFontSize, max=maxFontSize, step=1 for granular control
- Show visual feedback: labels display current values (e.g., "Terminal Font Size: 13px")
- Provide slider bounds documentation to help users understand sensitivity ranges
</learning>

<learning type="gotcha">
When implementing pinch detection alongside swipe gestures:
- Must check e.touches.length at multiple points: start, move, and end
- In handleTouchEnd, check if it was a pinch by looking at touchSecondStartRef
- Handle pinch case FIRST with early return before processing swipe logic
- This prevents accidentally triggering swipe callbacks when pinch ends
- Pinch detection relies on scale change threshold (pinchThreshold), not distance threshold
</learning>

<learning type="gotcha">
Font size boundary enforcement:
- Always clamp in the store setter, not in the component
- xterm.js may behave unexpectedly with extreme font sizes (< 8px or > 32px)
- Establish clear min/max bounds and communicate them in UI
- Test edge cases: manual slider adjustment to min/max, multiple rapid pinch gestures
</learning>

[2026-01-24T13:35:30.000000+00:00] [Iter 21] [END] Iteration 21 completed successfully
[2026-01-24T12:03:40.597692+00:00] [Iter 21] [END] Iteration 21 completed successfully
[2026-01-24T12:03:40.601985+00:00] [Iter 22] [START] Starting iteration 22

[2026-01-24T13:40:00.000000+00:00] [Iter 22] [US-5.6] Story Completed: Configure Gesture Preferences

<learning type="pattern">
Gesture settings UI implementation is complete and fully functional:
- GestureSettings component displays all 5 gesture features with individual toggle switches
- Each feature has configurable sensitivity threshold via slider (10-100px range)
- Font size adjustment slider for pinch-zoom feature (8-32px range)
- Reset button calls resetToDefaults() to restore original settings
- Component is integrated into SettingsPage.tsx at the UI Preferences tab (line 2240)
- Zustand persist middleware with name 'ralph-gesture-settings' ensures localStorage persistence
- All settings persist automatically across sessions
</learning>

<learning type="pattern">
Gesture settings store architecture provides complete feature toggle system:
- All gesture features have enable/disable toggles in DEFAULT_SETTINGS
- Feature-specific threshold setters update store state with proper immutability patterns
- resetToDefaults() method provides one-call reset of all settings to initial state
- Font size bounds enforced in setTerminalFontSize: Math.max(min, Math.min(value, max))
- Zustand persist middleware partializes only settings state (not entire store)
</learning>
[2026-01-24T12:04:51.422601+00:00] [Iter 22] [END] Iteration 22 completed successfully
[2026-01-24T12:04:51.425254+00:00] [Iter 23] [START] Starting iteration 23

[2026-01-24T13:45:00.000000+00:00] [Iter 23] [US-6.1] Story Completed: Receive Haptic Feedback

<learning type="pattern">
Haptic feedback implementation for terminal key bar:
- Add enableHaptics: boolean field to gesture settings interface
- Light haptic for normal key press: navigator.vibrate(10) for 10ms
- Medium haptic for modifier toggle: navigator.vibrate(20) for 20ms
- Always check navigator.vibrate availability and settings.enableHaptics before calling
- Add toggleHaptics() action to gesture store
- Default to enabled (enableHaptics: true) so feature works immediately
- Zustand persist middleware automatically saves setting to localStorage with name 'ralph-gesture-settings'
</learning>

<learning type="pattern">
Integrating haptic feedback into key press handler:
- For modifier keys: provide medium haptic (20ms) when toggling state in both single-tap (sticky) and double-tap (lock) cases
- For normal keys: provide light haptic (10ms) before sending the key to terminal
- Both cases check: if (settings.enableHaptics && navigator.vibrate) before calling vibrate()
- Add settings.enableHaptics to useCallback dependencies to ensure handlers update when setting changes
- The check for navigator.vibrate availability handles devices without vibration support gracefully
</learning>

<learning type="pattern">
Haptic feedback UI in gesture settings component:
- Add toggleHaptics to destructured imports from useGestureStore
- Create new settings section with border and muted background (consistent with other gesture features)
- Show description of what types of haptics are used (light for normal, medium for modifiers)
- Show conditional details when haptics are enabled:
  - Bullet point: "Light haptic (10ms) on normal key press"
  - Bullet point: "Medium haptic (20ms) on modifier toggle"
  - Bullet point: "Requires device support for vibration"
- Use existing Switch component for toggle
</learning>

<learning type="gotcha">
When adding haptic feedback timing:
- 10ms is subtle enough for normal key feedback without being annoying
- 20ms is noticeable enough for modifier state changes which are important mode indicators
- Always test on real devices as vibration patterns may vary
- The haptic feedback should enhance UX without being excessive or distracting
- Consider battery impact - lighter durations (10-20ms) have minimal impact
</learning>

[2026-01-24T13:45:30.000000+00:00] [Iter 23] [END] Iteration 23 completed successfully
[2026-01-24T12:06:48.274593+00:00] [Iter 23] [END] Iteration 23 completed successfully
[2026-01-24T12:06:48.277131+00:00] [Iter 24] [START] Starting iteration 24

[2026-01-24T13:50:00.000000+00:00] [Iter 24] [US-6.2] Story Completed: See Visual Feedback for Actions

<learning type="pattern">
Visual feedback implementation for terminal key bar actions is comprehensive:
- Key press ripple/highlight: Already implemented via active:bg-accent active:scale-95 CSS classes in TerminalKeyBar
- Gesture directional indicators: Already implemented in TerminalInstance with colored overlays (blue for up, green for down, purple for left, orange for right) with text labels
- Modifier state visibility: Active modifiers show bg-accent text-accent-foreground (highlighted), locked modifiers show border-accent border-2 animate-pulse (pulsing border)
- Command execution confirmation: Added executedCommandId state to CustomCommandsSheet, shows green flash + checkmark badge for 600ms
</learning>

<learning type="pattern">
Command execution feedback in CustomCommandsSheet:
- Add executedCommandId state to track which command was just executed
- Modify handleUseCommand to accept cmdId parameter and temporarily set executedCommandId
- Show green visual feedback on command card: bg-green-500/20 border-green-500/50 with "‚úì Executed" badge
- Use animate-pulse class on confirmation badge for subtle pulsing effect
- Clear executedCommandId after 600ms timeout to reset visual state
- Update all command card onClick handlers to pass cmd.id to handleUseCommand
</learning>

<learning type="gotcha">
When implementing command execution confirmation:
- Must import Check icon from lucide-react for the checkmark in the execution badge
- Update handleUseCommand signature to accept cmdId as first parameter before cmd and action
- The executedCommandId state is temporary and only lasts 600ms before clearing
- Both the card background AND the badge provide layered visual feedback for better UX
- The confirmation appears inline with the action badge at the bottom of the command card
</learning>
[2026-01-24T12:08:43.127422+00:00] [Iter 24] [END] Iteration 24 completed successfully
[2026-01-24T12:08:43.130929+00:00] [Iter 25] [START] Starting iteration 25

[2026-01-24T13:55:00.000000+00:00] [Iter 25] [US-6.3] Story Completed: Discover Gestures and Features

<learning type="pattern">
Onboarding store implementation for tracking first-time user experience:
- Create Zustand store with dismissed hints tracking using Set<string>
- Store persists dismissed hints array to localStorage, merge converts back to Set
- hasHintBeenDismissed method checks if specific hint ID is in the set
- markMainOnboardingAsSeen and resetOnboarding provide state management actions
- Partialize/merge pattern handles Set serialization since localStorage only supports JSON
</learning>

<learning type="pattern">
First-time onboarding modal architecture:
- Create step-based modal with multi-step carousel design (5 steps: welcome, modifiers, gestures, customization, help)
- Use hasSeenMainOnboarding store state to show modal on first visit (conditional render)
- Each step contains icon, title, description, and detailed content section
- Progress indicator shows current step with dot visualization (small dots, large for current)
- Skip and Next buttons allow user to navigate through steps or exit early
- Modal closes automatically when user completes all steps or clicks Skip
</learning>

<learning type="pattern">
Gesture-first tooltip hints for mobile features:
- Show tooltip hint only on first use of each gesture type (history navigation, cursor movement, page scroll)
- Integrate with onboarding store: check hasHintBeenDismissed before showing each hint
- Tooltip appears at bottom of terminal with semi-dark background, title, description, and close button
- Include "Visit Settings for more options" text to guide users to full documentation
- Hints auto-dismiss when user closes them (sets dismissHint in store)
- Use TypeScript union type for hint state: { id, title, description } | null
</learning>

<learning type="pattern">
Help button in settings for comprehensive documentation:
- Add Help icon button to card header using relative positioning and justify-between
- Dialog opens with scrollable content area (max-h-[80vh] overflow-y-auto)
- Organize help content by gesture type (5 sections: history, cursor, page scroll, extended arrows, pinch)
- Each section includes UI components as visual guide, detailed explanation, and technical details
- Include tips section with accent background color highlighting best practices
- Use consistent styling for instruction rows with font-medium labels and text-muted-foreground descriptions
</learning>

<learning type="gotcha">
When implementing onboarding with first-visit detection:
- Don't call setState synchronously within useEffect - causes cascading renders
- Instead, use store state directly to determine if modal should render (conditional JSX)
- Only dispatch actions in response to user interactions (button clicks, dialog close)
- This pattern avoids ESLint react-hooks/set-state-in-effect warnings
</learning>

<learning type="gotcha">
Gesture hint timing and lifecycle:
- Hints should appear AFTER gesture is detected and executed (not before)
- Call dismissHint(id) when user closes hint to update store and prevent re-showing
- Keep hint state separate from gesture indicator state to allow showing both simultaneously
- Clear gesture indicator after 200ms but keep hint visible until user dismisses
- Test that hints don't show on second use of same gesture (dismissal persists in localStorage)
</learning>

[2026-01-24T13:55:30.000000+00:00] [Iter 25] [END] Iteration 25 completed successfully
