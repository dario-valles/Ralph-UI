# Ralph Wiggum Loop Progress
# This file tracks learnings across agent iterations.
# Each agent reads this file to catch up on context.
# Initialized: 2026-01-24T11:11:36.090461+00:00

[2026-01-24T11:11:49.093664+00:00] [Iter 1] [START] Starting iteration 1

[2026-01-24T12:14:00.000000+00:00] [Iter 1] [US-1.1] Story Completed: Access Essential Terminal Keys

<learning type="architecture">
Terminal input system uses writeToTerminal(terminalId, data) from src/lib/terminal-api.ts.
The function looks up the PTY instance and calls pty.write(data), which sends a JSON message
over WebSocket with type: 'input' and the data field. xterm.js handles the actual keyboard
events in TerminalInstance.tsx and connects via terminal.onData() callback.
</learning>

<learning type="pattern">
Mobile-specific UI patterns in this codebase:
- Use useIsMobile() hook to detect mobile
- Hide desktop-only features with conditional rendering (e.g., split controls)
- Use 'safe-bottom' CSS class for iOS safe area insets
- Test mobile components at 320px width minimum
- Use Tailwind responsive prefixes for scaling (md:, lg:)
</learning>

<learning type="pattern">
Escape sequences for terminal keys:
- Tab: '\t' (0x09)
- Enter: '\r' (0x0D)
- Backspace: '\x7f' (DEL character)
- ^C (interrupt): '\x03'
- Arrow keys: '\x1b[A' (up), '\x1b[B' (down), '\x1b[D' (left), '\x1b[C' (right)
- Home: '\x1b[H', End: '\x1b[F'
</learning>

<learning type="pattern">
Haptic feedback in React: Use navigator.vibrate(duration) for light feedback (10ms).
This is supported on most mobile devices. Always check availability with if (navigator.vibrate).
</learning>

<learning type="gotcha">
The TerminalPanel component renders terminals in a flex layout with recursive PaneRenderer.
When adding the key bar, wrap terminal content in a flex column container to allow flex-1
sizing to work correctly. Don't add the key bar directly at panel level.
</learning>
[2026-01-24T11:14:48.671465+00:00] [Iter 1] [END] Iteration 1 completed successfully
[2026-01-24T11:14:48.674575+00:00] [Iter 2] [START] Starting iteration 2

[2026-01-24T12:15:00.000000+00:00] [Iter 2] [US-1.2] Story Completed: Use Modifier Keys (Ctrl/Alt)

<learning type="pattern">
Modifier key implementation for terminal key bar:
- Track modifier state with useRef (lastClickRef) and useState (modifierState)
- Use 300ms window for double-tap detection (single tap = sticky, double tap = lock)
- Ctrl combinations: For single chars, use charCode - 96 to get Ctrl value (e.g., 'a' -> 0x01)
- Alt combinations: Send ESC prefix (0x1b) followed by the key
- Auto-clear sticky mode either after non-modifier key press or after 5-second timeout
- Visual feedback: bg-accent + text-accent-foreground for active, add border-2 + animate-pulse for locked
</learning>

<learning type="pattern">
Terminal modifier key handling in escape sequences:
- Ctrl+C is already defined as '\x03' (special interrupt sequence)
- For general Ctrl+letter combinations: charCode - 96 works for lowercase a-z
- Alt is represented by ESC prefix (\x1b) sent before the actual key
- The terminal emulator (xterm.js) interprets these sequences correctly
</learning>

<learning type="gotcha">
When implementing modifier keys, be careful about:
- Always clear the double-tap timeout when transitioning states (to avoid stale timeouts)
- Clean up timeouts on component unmount to prevent memory leaks
- Use separate state tracking for Ctrl vs Alt to allow independent modifier states
- Test that modifier state properly clears after non-modifier key press (sticky mode)
- Verify that lock mode persists across multiple key presses
</learning>
[2026-01-24T11:17:09.158966+00:00] [Iter 2] [END] Iteration 2 completed successfully
[2026-01-24T11:17:09.161442+00:00] [Iter 3] [START] Starting iteration 3

[2026-01-24T12:18:00.000000+00:00] [Iter 3] [US-1.3] Story Completed: Interrupt Running Processes

<learning type="pattern">
Interrupt button design for terminal key bar:
- The ^C button should always send pure interrupt signal (\x03), independent of modifier state
- Always separate modifier handling for interrupt key - check for button label before applying modifiers
- Use destructive styling (bg-destructive/10 text-destructive) to make interrupt button visually prominent
- Interrupt button state should not be affected by active modifiers (Ctrl/Alt)
</learning>

<learning type="gotcha">
When implementing special keys like interrupt (^C):
- Don't apply active modifiers (Ctrl/Alt prefix) to interrupt signals
- Always send clean interrupt value regardless of modifier state - this ensures reliability
- Structurally, check for special keys BEFORE modifier application logic, not inside
- This pattern makes the intent clear and prevents subtle bugs with modifier combinations
</learning>
[2026-01-24T12:18:30.000000+00:00] [Iter 3] [END] Iteration 3 completed successfully
[2026-01-24T11:19:10.528448+00:00] [Iter 3] [END] Iteration 3 completed successfully
[2026-01-24T11:19:10.532654+00:00] [Iter 4] [START] Starting iteration 4

[2026-01-24T12:20:00.000000+00:00] [Iter 4] [US-1.4] Story Completed: Auto-Hide Key Bar with Physical Keyboard

<learning type="pattern">
Physical keyboard detection for auto-hide functionality:
- Use KeyboardEvent.code property to detect physical keyboards (it's populated for hardware keys)
- Check event.code !== '' to ensure it's a real keyboard event, not virtual
- Exclude input/textarea keydown events as they trigger virtual keyboards on mobile
- Implement 2-second timeout that resets on each keyboard activity for seamless experience
- Use opacity-0 + pointer-events-none + max-h-0 for smooth fade animation with CSS transitions
</learning>

<learning type="pattern">
State management for visibility toggle in React:
- Use useState(true) for initial visibility to show key bar on first mount
- Track visibility separately from other states (modifier state, etc.)
- Use useEffect with dependency on isMobile and activeTerminalId to enable/disable listeners
- Clean up all event listeners and timeouts in useEffect return callback to prevent memory leaks
</learning>

<learning type="gotcha">
When implementing keyboard detection:
- The event listener must check both event.code AND !isFromInput to avoid false positives
- Always clear existing timeout before setting a new one to prevent race conditions
- Event delegation via window.addEventListener('keydown') works globally for all keyboard input
- Remember to handle visibilitychange event (tab switch) and explicitly show key bar to ensure UX
</learning>
[2026-01-24T12:20:30.000000+00:00] [Iter 4] [END] Iteration 4 completed successfully
[2026-01-24T11:20:59.056147+00:00] [Iter 4] [END] Iteration 4 completed successfully
[2026-01-24T11:20:59.060269+00:00] [Iter 5] [START] Starting iteration 5

[2026-01-24T12:25:00.000000+00:00] [Iter 5] [US-2.1] Story Completed: Rearrange Keys

<learning type="pattern">
Key bar layout customization architecture:
- Create separate Zustand store (keyBarLayoutStore) for layout persistence
- Store icon names as strings in the store (not React components) for serialization
- Map icon names to components in the component using a const ICON_MAP
- Use useMemo in TerminalKeyBar to convert stored layout to component layout on mount
- This separation ensures store data is serializable and components remain flexible
</learning>

<learning type="pattern">
HTML5 drag-and-drop implementation for key rearrangement:
- Use native HTML5 drag events: onDragStart, onDragOver, onDrop
- Track draggedIndex in state during the drag operation
- In onDragOver, prevent default and set dropEffect = 'move'
- In onDrop, splice the dragged item from source index and insert at target index
- Clear draggedIndex after drop completes
- This approach works without external libraries
</learning>

<learning type="pattern">
Integrating customizer into existing settings page:
- Add new component to appropriate settings tab (UI Preferences for key bar)
- Import the customizer component at top of SettingsPage
- Add it to the TabsContent section alongside other settings
- This keeps settings organized while maintaining modularity
</learning>

<learning type="gotcha">
When removing unused code from TerminalKeyBar:
- The DEFAULT_KEYS array is now defined in the store, not the component
- Remove it from the component to pass linting (no-unused-vars rule)
- The store exports DEFAULT_LAYOUT which can be referenced for reset functionality
</learning>

[2026-01-24T12:25:30.000000+00:00] [Iter 5] [END] Iteration 5 completed successfully
[2026-01-24T11:24:20.856651+00:00] [Iter 5] [END] Iteration 5 completed successfully
[2026-01-24T11:24:20.861714+00:00] [Iter 6] [START] Starting iteration 6

[2026-01-24T12:30:00.000000+00:00] [Iter 6] [US-2.2] Story Completed: Add and Remove Keys

<learning type="pattern">
Key palette implementation for terminal key bar:
- Define AVAILABLE_KEYS array in the Zustand store with 50+ keys categorized by type (navigation, editing, modifiers, control sequences, function keys, common characters)
- Use filter() to get available keys not already in the layout
- Implement search with toLowerCase() matching on both label and ariaLabel for better UX
- Separate palette visibility from main editor with a collapsible section (show/hide via state)
- Use grid layout (grid-cols-3) for compact palette display with max-h-64 overflow-y-auto for scrolling
</learning>

<learning type="pattern">
Add/remove constraints and validation for key bar:
- Define MIN_KEYS = 6 and MAX_KEYS_PER_ROW = 10 as constants
- Disable remove button (with visual feedback) when at minimum keys using opacity-50 + cursor-not-allowed
- Show helpful tooltip when action is disabled to explain the constraint
- Calculate rows by dividing layout into chunks of MAX_KEYS_PER_ROW for visual row preview
- Validate constraints in handleSave() before persisting to store, show alert on failure
- Show row count and key count in the preview section to help users understand layout
</learning>

<learning type="pattern">
Visual feedback for add/remove operations:
- Show live preview that updates immediately as keys are added/removed (not just on save)
- Display row-based layout preview to show how keys will wrap at max per-row constraint
- Show count of available keys and current key count for transparency
- Display "All available keys are in use" message when palette is full
- Use "unsaved changes" warning to ensure user explicitly saves before changes persist
- Clear search query after adding key to keep UI clean
</learning>

<learning type="gotcha">
When managing complex component state with multiple related fields:
- Must track both layout state and hasChanges state separately
- searchQuery and showPalette are UI-only state that don't need to be persisted
- Use useMemo or inline calculations for derived values like availableKeysToAdd and filteredAvailableKeys
- Calculate canRemoveMore and isFull at render time to ensure they stay in sync with layout
- Test that all state transitions are correct (adding, removing, searching, palette toggle)
</learning>

[2026-01-24T12:30:30.000000+00:00] [Iter 6] [END] Iteration 6 completed successfully
[2026-01-24T11:27:05.443680+00:00] [Iter 6] [END] Iteration 6 completed successfully
[2026-01-24T11:27:05.446978+00:00] [Iter 7] [START] Starting iteration 7

[2026-01-24T12:35:00.000000+00:00] [Iter 7] [US-2.3] Story Completed: Use and Save Presets

<learning type="pattern">
Preset system implementation for terminal key bar:
- Create Preset interface with id, name, layout, and isBuiltin flag
- Store presets array in Zustand with built-in presets initialized by default
- Track activePresetId to know which preset is currently selected
- Implement store methods: savePreset (generates ID from timestamp), switchPreset, deletePreset, getActivePreset
- Built-in presets cannot be deleted (checked via isBuiltin flag)
- Custom presets get unique IDs like 'preset-custom-{timestamp}'
- When switching presets, clear customLayout to ensure preset layout is used
- All preset operations persist to localStorage via Zustand persist middleware
</learning>

<learning type="pattern">
Preset UI implementation in key bar customizer:
- Display presets in a vertical list with one button per preset
- Highlight active preset with accent color and border-2
- Show delete button only for custom presets (isBuiltin === false)
- "Save as preset" button disabled when no changes (hasChanges === false)
- Use controlled input dialog for preset name with Enter key support
- Show preset list above the current layout preview for easy discoverability
- Grid layout breaks down on mobile (single preset per row) and expands to 2-4 cols on md+
</learning>

<learning type="pattern">
Built-in presets design:
- Default: Full keyboard layout with all standard keys
- Git: Optimized for git workflows (arrows, slash, hyphen, Ctrl, Alt, ^C)
- Vim: Optimized for vim/nano editors (arrows, colon, slash, Escape key)
- Node: Optimized for JavaScript development (parens, braces, semicolon, colon)
- Each preset has 11-12 keys (respects MIN_KEYS = 6 and MAX_KEYS_PER_ROW = 10)
</learning>

<learning type="gotcha">
When implementing preset switching:
- Must clear customLayout when switching presets to avoid confusion
- activePresetId should be set to 'preset-default' when deleting the active custom preset
- Store methods should validate that presets exist before returning them (defensive coding)
- Be careful with preset IDs - use consistent naming scheme for builtin (preset-{name}) vs custom (preset-custom-{timestamp})
</learning>
[2026-01-24T12:35:30.000000+00:00] [Iter 7] [END] Iteration 7 completed successfully
[2026-01-24T11:29:09.507687+00:00] [Iter 7] [END] Iteration 7 completed successfully
[2026-01-24T11:29:09.511374+00:00] [Iter 8] [START] Starting iteration 8

[2026-01-24T12:40:00.000000+00:00] [Iter 8] [US-3.1] Story Completed: Save Frequently Used Commands

<learning type="pattern">
Custom commands store implementation for terminal:
- Create dedicated Zustand store with localStorage persistence (useCustomCommandsStore)
- Store interface: CustomCommand with id, label, command, createdAt timestamp
- Store actions: addCommand, deleteCommand, getCommands
- Command IDs use format 'cmd-{timestamp}' for unique identification
- All store data is serializable (no React components)
</learning>

<learning type="pattern">
Custom commands side sheet UI architecture:
- CustomCommandsSheet component wraps mobile-friendly sheet UI for command management
- Includes form for adding commands with label and command text inputs
- Shows all saved commands in a scrollable list
- Each command has a clickable label/command area to execute and delete button
- Uses writeToTerminal(activeTerminalId, command) to execute saved commands
- Empty state message when no commands exist
</learning>

<learning type="pattern">
Integration with TerminalKeyBar:
- Add CustomCommandsSheet import and state (isCommandsSheetOpen)
- Add custom commands button (BookOpen icon) at the end of the key bar
- Button opens sheet via onClick handler
- Sheet is rendered as sibling to key bar div to avoid z-index issues
- Fragment wrapper needed when returning both key bar and sheet
</learning>

<learning type="gotcha">
When adding multiple components to TerminalKeyBar:
- Must wrap in Fragment (<>) when returning multiple JSX elements
- Import additional icons needed for new buttons (BookOpen for custom commands)
- Clean up unused imports to pass linting (cn was imported but not used initially)
- All button styling should follow existing patterns (min-h-[32px] min-w-[40px])
</learning>

[2026-01-24T12:40:30.000000+00:00] [Iter 8] [END] Iteration 8 completed successfully
[2026-01-24T11:31:38.143409+00:00] [Iter 8] [END] Iteration 8 completed successfully
[2026-01-24T11:31:38.147972+00:00] [Iter 9] [START] Starting iteration 9

[2026-01-24T12:45:00.000000+00:00] [Iter 9] [US-3.2] Story Completed: Choose Insert vs Execute Action

<learning type="pattern">
Custom command action type implementation for terminal:
- Add action: 'insert' | 'execute' field to CustomCommand interface
- Store tracks action type along with label and command text
- When creating commands, default action is 'execute' for convenience
- Execute action sends newline (\r) after the command to run it
- Insert action only pastes the command text without sending newline
- Visual badge shows action type: "‚Üµ Execute" (primary/blue) or "‚Üê Insert" (secondary)
- Uses conditional className based on action type to differentiate styling
</learning>

<learning type="pattern">
Form pattern for enum selection in React:
- Use controlled input with select element
- Pass action to handleAddCommand function
- Reset action to default ('execute') on form cancel to avoid state leakage
- Use TypeScript type casting: e.target.value as 'insert' | 'execute'
- Show user-friendly labels in options ("Insert (no newline)" vs "Execute (with newline)")
</learning>

<learning type="gotcha">
When implementing command execution with multiple behavior options:
- Must track which action type was selected with the command
- Store action type persistently so it applies when command is reused
- Default to 'execute' since most users expect commands to run automatically
- Visual indicator must be clear and discoverable (badge at bottom of command card)
- Test that both actions work correctly: insert (no newline) and execute (with newline)
</learning>
[2026-01-24T12:45:30.000000+00:00] [Iter 9] [END] Iteration 9 completed successfully
[2026-01-24T11:33:41.104011+00:00] [Iter 9] [END] Iteration 9 completed successfully
[2026-01-24T11:33:41.106968+00:00] [Iter 10] [START] Starting iteration 10

[2026-01-24T12:50:00.000000+00:00] [Iter 10] [US-3.3] Story Completed: Organize Commands with Categories

<learning type="pattern">
Command category system implementation for terminal:
- Add category: string field to CustomCommand interface
- Store methods: getCommandsByCategory(category) and getAllCategories() return filtered/unique categories
- Sheet state: expandedCategories is Set<string> to track which categories are expanded
- Grouping: Use useMemo to create groupedCommands Record<string, CustomCommand[]> with Object.entries().sort()
- UI: Category headers with ChevronDown/ChevronRight icons toggle visibility, commands nested in container
- Filtering: selectedFilter state with filter buttons showing counts per category
- Form: Category select dropdown with special option for new categories (value="") then input field to enter name
</learning>

<learning type="gotcha">
When implementing category features:
- Must track expandedCategories as a Set, not array, for O(1) lookups when toggling visibility
- Category selection form needs special handling for new categories: select value="" shows input field
- Need to reset category back to 'Uncategorized' when closing form to avoid state leakage
- getAllCategories() must use Set to deduplicate then sort alphabetically for consistent UI
- groupedCommands needs proper Object.entries().sort() to ensure consistent ordering across renders
</learning>
[2026-01-24T11:35:41.699632+00:00] [Iter 10] [END] Iteration 10 completed successfully
[2026-01-24T11:35:41.702181+00:00] [Iter 11] [START] Starting iteration 11

[2026-01-24T12:55:00.000000+00:00] [Iter 11] [US-3.4] Story Completed: Search Commands

<learning type="pattern">
Search functionality implementation for custom commands:
- Add searchQuery state to track user input
- Create filteredCommands useMemo that filters based on searchQuery using toLowerCase() matching on both label and command fields
- Create displayedGroups useMemo that groups filtered commands by category and applies category filter
- Show search input conditionally: only when commands.length > 10
- Add X (clear) button using lucide-react's X icon that appears when searchQuery is non-empty
- Update category filter counts to use filteredCommands instead of commands for accurate filtering display
- Remove old unused groupedCommands memoization to pass linting
</learning>

<learning type="pattern">
Search UI placement and interaction:
- Search input appears after the "Add Command" button and before the "Add Command Form"
- Use relative positioning for the clear button (X icon) positioned at right side of input
- Search field has placeholder "Search commands..." to guide users
- Results update immediately as user types (real-time filtering)
- Clear button has aria-label for accessibility
</learning>

<learning type="gotcha">
When implementing filtered search with category grouping:
- Must ensure both useMemo dependencies are correct (filteredCommands in displayedGroups, searchQuery in filteredCommands)
- Category filter counts must use filteredCommands not commands to show correct filtered counts
- The old groupedCommands memoization should be removed to avoid unused variable errors
- Search query should be reset when user clears (happens automatically via setSearchQuery)
</learning>
[2026-01-24T11:37:11.330265+00:00] [Iter 11] [END] Iteration 11 completed successfully
[2026-01-24T11:37:11.332687+00:00] [Iter 12] [START] Starting iteration 12

[2026-01-24T12:58:00.000000+00:00] [Iter 12] [US-3.5] Story Completed: Manage Commands (Edit/Delete/Reorder)

<learning type="pattern">
Command edit/delete/reorder implementation for custom commands:
- Add sortOrder field to CustomCommand interface to track drag-and-drop order
- Store actions: editCommand updates existing command fields, reorderCommands replaces entire array
- Edit flow: populate form fields from existing command, set editingId, then call editCommand on save
- Delete flow: use deleteConfirmId state for confirmation dialog to prevent accidental deletion
- Reorder flow: track draggedIndex on drag start, find target index on drop, splice and reorder array
- Form UX: show "Edit Command" vs "Add New Command" title based on editingId, reset form on cancel
</learning>

<learning type="pattern">
HTML5 drag-and-drop for list reordering in React:
- Use draggable attribute on each item to enable native drag events
- Track draggedIndex in state during drag operation
- onDragStart captures which index is being dragged
- onDragOver(e) prevents default and sets dropEffect='move' to show move cursor
- onDrop(targetIndex) reorders array: splice dragged item, insert at target, update state
- Visual feedback: apply opacity-50 to dragged item, change background color for drop target
- Important: Clear draggedIndex after drop to reset visual state
</learning>

<learning type="gotcha">
When implementing edit functionality alongside add:
- Must track editingId state separately to know if in edit mode
- Form fields need proper initialization from existing command data
- Must reset editingId to null after save to avoid stale state
- handleCancelForm must reset all fields AND editingId to prevent form leaking state
- Reset form fields on successful add/edit to prepare for next operation
</learning>

<learning type="gotcha">
When adding multiple buttons (edit/delete) to command cards:
- Wrap buttons in flex container with gap-1 to keep them close together
- Use separate w-6 h-6 styling for consistency with previous delete-only design
- For delete, use deleteConfirmId state instead of immediate deletion
- Confirmation dialog prevents accidental deletions from mobile fat-finger errors
- Delete confirmation is shown inline on the command card, not as separate modal
</learning>
[2026-01-24T11:39:42.000000+00:00] [Iter 12] [END] Iteration 12 completed successfully
[2026-01-24T11:39:02.179644+00:00] [Iter 12] [END] Iteration 12 completed successfully
[2026-01-24T11:39:02.183810+00:00] [Iter 13] [START] Starting iteration 13

[2026-01-24T12:60:00.000000+00:00] [Iter 13] [US-4.1] Story Completed: Sync Commands Within a Project

<learning type="pattern">
Project-scoped command storage implementation:
- Add scope field to CustomCommand interface: 'local' | 'project' | 'global'
- Create dedicated backend module (server/src/commands/terminal.rs) for terminal commands
- Implement two async functions: save_project_commands and load_project_commands
- Store project commands in {projectPath}/.ralph-ui/terminal/commands.json for git tracking
- Use atomic writes (write to temp, rename) for safe file operations
- Zustand store handles merging local + project commands on load
</learning>

<learning type="pattern">
Backend command routing pattern:
- Add new command handlers to server/src/server/proxy.rs route_command match statement
- Use route_async! macro for async commands that return values
- Register new modules in server/src/commands/mod.rs (both pub mod and pub use)
- Frontend invoke() calls automatically route to backend handlers
- All backend functions return Result<T, String> or Result<Value, String>
</learning>

<learning type="pattern">
Frontend scope selection UI:
- Add scope state to form component alongside existing action, category, label, command
- Create select dropdown with three options: Local, Project (disabled if no projectPath), Global (disabled, coming soon)
- Show visual scope badges on command cards with different colors (üì± Local, üîÑ Project, üåê Global)
- Make save/cancel buttons disabled during async operations to prevent double-submit
</learning>

<learning type="gotcha">
When implementing scope feature:
- Must pass scope parameter through all store methods: addCommand, editCommand, deleteCommand, reorderCommands
- All store methods become async because they may need to sync with backend
- Need to track projectPath in store and only attempt save if projectPath is set
- Default scope should be 'local' unless editing existing command with different scope
- Each scope-specific operation filters commands before syncing to backend
</learning>

[2026-01-24T12:62:00.000000+00:00] [Iter 13] [END] Iteration 13 completed successfully
